# cs1710 Final Project README

* What tradeoffs did you make in choosing your representation? What else did you try that didnâ€™t work as well?
    * For context, two of our Curiosity Modeling projects were modeling a 4x4 sudoku board, so we first modified that to expand to a 9x9 board. Our 9x9 version only showed a starting state, random middle state, and solved state. For the middle state, we tried to branch off into more specific middle states (ex. grid by grid or row by row) but ran into bitwidth issues when specifying constraints. We realized that it wouldn't be useful to show the middle state when the puzzle had already been solved because we weren't demonstrating any new information about how you play.
    * We also thought about exploring unique solutions and prove the fact that the minimum number of starting entries in a sudoku puzzle is 17. However, this would have incorporated z3 and none of us felt particularly confident moving in that direction.
    * We eventually looked into representing sudoku in temporal mode so that we could learn more about how the games are played through traces. We thought this would give us more insight into how the board can change at each state, and what the length of traces could show us. But when we were generating starting states we ran into bitwidth issues again and spent lots of time trying to figure out ways around it. 
        * This limited our ability to represent strategies or design different starting boards. Though we could get one or two correct instances, we could not constrain the rest of the cells to stay empty which made testing properties difficult.

* What assumptions did you make about scope? What are the limits of your model?
    * Our initial assumptions about the scope was that it would be feasible to do a 9x9 in temporal mode.
        * We realized that our model is quite limited in the bitwidth that the traces are ran on. Our model relies on keeping count on the number of cells that are filled in on the board. Counting for 81 cells would require 8 bits, which our computers were not able handle (Unfamiliar server errors would result). Through testing different board sizes, we saw that a 4x4 in 5 bits was the largest board with a acceptable runtime for producing instances. 
    * Another assumption we made was that uniqueness would not be something we could assess. 
        * Our model is limited in that it cannot assess uniqueness as it can only produce one instance at a time. z3 would have been an option where we could evaluate this, but we chose to explore other features of the model and just acknowledge this limitation in our model. 

* Did your goals change at all from your proposal? Did you realize anything you planned was unrealistic, or that anything you thought was unrealistic was doable?
    * Our foundation goal for the project was to increase the scalability from a 4x4 board (which we had in Curiosity Modeling) to a 9x9 board. 
        * We created a 9x9 version of the sudoku model, which can be found in the repository under the 9x9 (non-temporal) folder. This model "generates" an unsolved board and provides a solution to the board. Creating this model proved to be much easier than we expected, which is why we continued to iterate our model to better understand sudoku as a puzzle. We added a "middle state" to learn how the board was being solved, but then realized we could have more control over each step if we switched to temporal mode.
    * Our target goal was to create a custom visualizer, generate starting boards (instead of hard coding a starting board), and also to make sure that only one entry changes between consecutive boards.
        * We were able to accomplish all of these goals, but we struggled to learn as much as we wanted about different starting boards because our constraints on the init board produced bitwidth issues we have been unable to work around.
        * For example, in our 9x9 board, we hoped to start with one grid filled entirely but we ran into unusual instances where the other cells were not staying empty. Additionally, in our 4x4 board we can only start with 4 empty spaces, despite having tried different bits and an optimizer. 
    * Our reach goal was to have our model generate starting boards that have only one correct solution. We also wanted to add an option for the user to indicate a difficulty mode that would adjust the starting board that is generated accordingly. It also would have been interesting to actually model a person playing Sudoku (which would involve showing incorrect moves and going back to fix it) instead of modeling a completely correct game of Sudoku.
        * Because of the issues we encountered with generating starting boards and the corresponding steps (especially once we reached the boards that had more than 4 empty entries) we determined that our reach goals were unrealistic. We chose to take a different route to further our understanding of sudoku and puzzles through modeling it in Forge.

* How should we understand an instance of your model and what your custom visualization shows?
    * An instance of our model is represented as one gameplay of sudoku. The first state will be the initialized starting board, the last state will be the completed board, and all states in between will be filling up the empty cells one by one. Our custom visualization shows the gameplay for a 4x4 grid. The visualization looks exactly the same as a standard 4x4 sudoku game. 